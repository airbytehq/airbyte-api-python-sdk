"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
import dataclasses
from airbyte_api import utils
from dataclasses_json import Undefined, dataclass_json
from enum import Enum
from typing import Any, Dict, Final, Optional, Union


class SourceNetsuiteEnterpriseSchemasAuthenticationMethodAuthenticationMethod(str, Enum):
    OAUTH2_AUTHENTICATION = 'oauth2_authentication'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class OAuth2Authentication:
    r"""Authenticate using OAuth2. This requires a consumer key, the private part of the certificate with which netsuite OAuth2 Client Credentials was setup and the certificate ID for the OAuth2 setup entry."""
    client_id: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('client_id') }})
    r"""The consumer key used for OAuth2 authentication. This is generated in NetSuite when creating an integration record."""
    key_id: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('key_id') }})
    r"""The certificate ID for the OAuth 2.0 Client Credentials Setup entry."""
    oauth2_private_key: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('oauth2_private_key') }})
    r"""The private portion of the certificate with which OAuth2 was setup. ( created with openssl req -new -x509 -newkey rsa:4096 -keyout private.pem -sigopt rsa_padding_mode:pss -sha256 -sigopt rsa_pss_saltlen:64 -out public.pem -nodes -days 365 )"""
    additional_properties: Optional[Dict[str, Any]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'exclude': lambda f: f is None }})
    authentication_method: Optional[SourceNetsuiteEnterpriseSchemasAuthenticationMethodAuthenticationMethod] = dataclasses.field(default=SourceNetsuiteEnterpriseSchemasAuthenticationMethodAuthenticationMethod.OAUTH2_AUTHENTICATION, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('authentication_method'), 'exclude': lambda f: f is None }})
    



class SourceNetsuiteEnterpriseSchemasAuthenticationMethod(str, Enum):
    TOKEN_BASED_AUTHENTICATION = 'token_based_authentication'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class TokenBasedAuthentication:
    r"""Authenticate using a token-based authentication method. This requires a consumer key and secret, as well as a token ID and secret."""
    client_id: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('client_id') }})
    r"""The consumer key used for token-based authentication. This is generated in NetSuite when creating an integration record."""
    client_secret: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('client_secret') }})
    r"""The consumer secret used for token-based authentication. This is generated in NetSuite when creating an integration record."""
    token_id: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('token_id') }})
    r"""The token ID used for token-based authentication. This is generated in NetSuite when creating a token-based role."""
    token_secret: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('token_secret') }})
    r"""The token secret used for token-based authentication. This is generated in NetSuite when creating a token-based role.Ensure to keep this value secure."""
    additional_properties: Optional[Dict[str, Any]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'exclude': lambda f: f is None }})
    authentication_method: Optional[SourceNetsuiteEnterpriseSchemasAuthenticationMethod] = dataclasses.field(default=SourceNetsuiteEnterpriseSchemasAuthenticationMethod.TOKEN_BASED_AUTHENTICATION, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('authentication_method'), 'exclude': lambda f: f is None }})
    



class SourceNetsuiteEnterpriseSchemasAuthenticationMethodAuthenticationMethodAuthenticationMethod(str, Enum):
    PASSWORD_AUTHENTICATION = 'password_authentication'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class SourceNetsuiteEnterprisePasswordAuthentication:
    r"""Authenticate using a password."""
    password: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('password') }})
    r"""The password associated with the username."""
    additional_properties: Optional[Dict[str, Any]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'exclude': lambda f: f is None }})
    authentication_method: Optional[SourceNetsuiteEnterpriseSchemasAuthenticationMethodAuthenticationMethodAuthenticationMethod] = dataclasses.field(default=SourceNetsuiteEnterpriseSchemasAuthenticationMethodAuthenticationMethodAuthenticationMethod.PASSWORD_AUTHENTICATION, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('authentication_method'), 'exclude': lambda f: f is None }})
    



class CursorMethod(str, Enum):
    USER_DEFINED = 'user_defined'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class SourceNetsuiteEnterpriseScanChangesWithUserDefinedCursor:
    r"""Incrementally detects new inserts and updates using the <a href=\\"https://docs.airbyte.com/understanding-airbyte/connections/incremental-append/#user-defined-cursor\\">cursor column</a> chosen when configuring a connection (e.g. created_at, updated_at)."""
    additional_properties: Optional[Dict[str, Any]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'exclude': lambda f: f is None }})
    cursor_method: Optional[CursorMethod] = dataclasses.field(default=CursorMethod.USER_DEFINED, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('cursor_method'), 'exclude': lambda f: f is None }})
    



class NetsuiteEnterprise(str, Enum):
    NETSUITE_ENTERPRISE = 'netsuite-enterprise'


class SourceNetsuiteEnterpriseSchemasTunnelMethodTunnelMethod(str, Enum):
    SSH_PASSWORD_AUTH = 'SSH_PASSWORD_AUTH'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class SourceNetsuiteEnterpriseSchemasPasswordAuthentication:
    r"""Connect through a jump server tunnel host using username and password authentication"""
    tunnel_host: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('tunnel_host') }})
    r"""Hostname of the jump server host that allows inbound ssh tunnel."""
    tunnel_user: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('tunnel_user') }})
    r"""OS-level username for logging into the jump server host"""
    tunnel_user_password: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('tunnel_user_password') }})
    r"""OS-level password for logging into the jump server host"""
    additional_properties: Optional[Dict[str, Any]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'exclude': lambda f: f is None }})
    tunnel_method: Optional[SourceNetsuiteEnterpriseSchemasTunnelMethodTunnelMethod] = dataclasses.field(default=SourceNetsuiteEnterpriseSchemasTunnelMethodTunnelMethod.SSH_PASSWORD_AUTH, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('tunnel_method'), 'exclude': lambda f: f is None }})
    tunnel_port: Optional[int] = dataclasses.field(default=22, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('tunnel_port'), 'exclude': lambda f: f is None }})
    r"""Port on the proxy/jump server that accepts inbound ssh connections."""
    



class SourceNetsuiteEnterpriseSchemasTunnelMethod(str, Enum):
    SSH_KEY_AUTH = 'SSH_KEY_AUTH'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class SourceNetsuiteEnterpriseSSHKeyAuthentication:
    r"""Connect through a jump server tunnel host using username and ssh key"""
    ssh_key: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('ssh_key') }})
    r"""OS-level user account ssh key credentials in RSA PEM format ( created with ssh-keygen -t rsa -m PEM -f myuser_rsa )"""
    tunnel_host: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('tunnel_host') }})
    r"""Hostname of the jump server host that allows inbound ssh tunnel."""
    tunnel_user: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('tunnel_user') }})
    r"""OS-level username for logging into the jump server host"""
    additional_properties: Optional[Dict[str, Any]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'exclude': lambda f: f is None }})
    tunnel_method: Optional[SourceNetsuiteEnterpriseSchemasTunnelMethod] = dataclasses.field(default=SourceNetsuiteEnterpriseSchemasTunnelMethod.SSH_KEY_AUTH, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('tunnel_method'), 'exclude': lambda f: f is None }})
    tunnel_port: Optional[int] = dataclasses.field(default=22, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('tunnel_port'), 'exclude': lambda f: f is None }})
    r"""Port on the proxy/jump server that accepts inbound ssh connections."""
    



class SourceNetsuiteEnterpriseTunnelMethod(str, Enum):
    NO_TUNNEL = 'NO_TUNNEL'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class SourceNetsuiteEnterpriseNoTunnel:
    r"""No ssh tunnel needed to connect to database"""
    additional_properties: Optional[Dict[str, Any]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'exclude': lambda f: f is None }})
    tunnel_method: Optional[SourceNetsuiteEnterpriseTunnelMethod] = dataclasses.field(default=SourceNetsuiteEnterpriseTunnelMethod.NO_TUNNEL, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('tunnel_method'), 'exclude': lambda f: f is None }})
    



@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class SourceNetsuiteEnterprise:
    account_id: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('account_id') }})
    r"""The username which is used to access the database."""
    authentication_method: SourceNetsuiteEnterpriseAuthenticationMethod = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('authentication_method') }})
    r"""Configure how to authenticate to Netsuite. Options include username/password or token-based authentication."""
    cursor: SourceNetsuiteEnterpriseUpdateMethod = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('cursor') }})
    r"""Configures how data is extracted from the database."""
    host: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('host') }})
    r"""Hostname of the database."""
    role_id: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('role_id') }})
    r"""The username which is used to access the database."""
    tunnel_method: SourceNetsuiteEnterpriseSSHTunnelMethod = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('tunnel_method') }})
    r"""Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use."""
    username: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('username') }})
    r"""The username which is used to access the database."""
    check_privileges: Optional[bool] = dataclasses.field(default=True, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('check_privileges'), 'exclude': lambda f: f is None }})
    r"""When this feature is enabled, during schema discovery the connector will query each table or view individually to check access privileges and inaccessible tables, views, or columns therein will be removed. In large schemas, this might cause schema discovery to take too long, in which case it might be advisable to disable this feature."""
    checkpoint_target_interval_seconds: Optional[int] = dataclasses.field(default=300, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('checkpoint_target_interval_seconds'), 'exclude': lambda f: f is None }})
    r"""How often (in seconds) a stream should checkpoint, when possible."""
    concurrency: Optional[int] = dataclasses.field(default=1, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('concurrency'), 'exclude': lambda f: f is None }})
    r"""Maximum number of concurrent queries to the database."""
    jdbc_url_params: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('jdbc_url_params'), 'exclude': lambda f: f is None }})
    r"""Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (example: key1=value1&key2=value2&key3=value3)."""
    port: Optional[int] = dataclasses.field(default=1708, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('port'), 'exclude': lambda f: f is None }})
    r"""Port of the database."""
    SOURCE_TYPE: Final[NetsuiteEnterprise] = dataclasses.field(default=NetsuiteEnterprise.NETSUITE_ENTERPRISE, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('sourceType') }})
    


SourceNetsuiteEnterpriseAuthenticationMethod = Union[SourceNetsuiteEnterprisePasswordAuthentication, TokenBasedAuthentication, OAuth2Authentication]

SourceNetsuiteEnterpriseUpdateMethod = Union[SourceNetsuiteEnterpriseScanChangesWithUserDefinedCursor]

SourceNetsuiteEnterpriseSSHTunnelMethod = Union[SourceNetsuiteEnterpriseNoTunnel, SourceNetsuiteEnterpriseSSHKeyAuthentication, SourceNetsuiteEnterpriseSchemasPasswordAuthentication]
