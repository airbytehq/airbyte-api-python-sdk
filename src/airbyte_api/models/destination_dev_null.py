"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
import dataclasses
from airbyte_api import utils
from dataclasses_json import Undefined, dataclass_json
from enum import Enum
from typing import Any, Dict, Final, Optional, Union


class DevNull(str, Enum):
    DEV_NULL = 'dev-null'


class DestinationDevNullSchemasTestDestinationTestDestinationType(str, Enum):
    FAILING = 'FAILING'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class Failing:
    num_messages: int = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('num_messages') }})
    r"""Number of messages after which to fail."""
    additional_properties: Optional[Dict[str, Any]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'exclude': lambda f: f is None }})
    test_destination_type: Optional[DestinationDevNullSchemasTestDestinationTestDestinationType] = dataclasses.field(default=DestinationDevNullSchemasTestDestinationTestDestinationType.FAILING, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('test_destination_type'), 'exclude': lambda f: f is None }})
    



class DestinationDevNullSchemasTestDestinationType(str, Enum):
    THROTTLED = 'THROTTLED'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class Throttled:
    millis_per_record: int = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('millis_per_record') }})
    r"""The number of milliseconds to wait between each record."""
    additional_properties: Optional[Dict[str, Any]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'exclude': lambda f: f is None }})
    test_destination_type: Optional[DestinationDevNullSchemasTestDestinationType] = dataclasses.field(default=DestinationDevNullSchemasTestDestinationType.THROTTLED, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('test_destination_type'), 'exclude': lambda f: f is None }})
    



class DestinationDevNullTestDestinationType(str, Enum):
    SILENT = 'SILENT'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class Silent:
    additional_properties: Optional[Dict[str, Any]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'exclude': lambda f: f is None }})
    test_destination_type: Optional[DestinationDevNullTestDestinationType] = dataclasses.field(default=DestinationDevNullTestDestinationType.SILENT, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('test_destination_type'), 'exclude': lambda f: f is None }})
    



class DestinationDevNullSchemasLoggingType(str, Enum):
    RANDOM_SAMPLING = 'RandomSampling'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class RandomSampling:
    r"""For each stream, randomly log a percentage of the entries with a maximum cap."""
    additional_properties: Optional[Dict[str, Any]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'exclude': lambda f: f is None }})
    logging_type: Optional[DestinationDevNullSchemasLoggingType] = dataclasses.field(default=DestinationDevNullSchemasLoggingType.RANDOM_SAMPLING, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('logging_type'), 'exclude': lambda f: f is None }})
    max_entry_count: Optional[float] = dataclasses.field(default=100, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('max_entry_count'), 'exclude': lambda f: f is None }})
    r"""Number of entries to log. This destination is for testing only. So it won't make sense to log infinitely. The maximum is 1,000 entries."""
    sampling_ratio: Optional[float] = dataclasses.field(default=0.001, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('sampling_ratio'), 'exclude': lambda f: f is None }})
    r"""A positive floating number smaller than 1."""
    seed: Optional[float] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('seed'), 'exclude': lambda f: f is None }})
    r"""When the seed is unspecified, the current time millis will be used as the seed."""
    



class DestinationDevNullLoggingType(str, Enum):
    EVERY_NTH = 'EveryNth'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class EveryNThEntry:
    r"""For each stream, log every N-th entry with a maximum cap."""
    nth_entry_to_log: int = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('nth_entry_to_log') }})
    r"""The N-th entry to log for each stream. N starts from 1. For example, when N = 1, every entry is logged; when N = 2, every other entry is logged; when N = 3, one out of three entries is logged."""
    additional_properties: Optional[Dict[str, Any]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'exclude': lambda f: f is None }})
    logging_type: Optional[DestinationDevNullLoggingType] = dataclasses.field(default=DestinationDevNullLoggingType.EVERY_NTH, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('logging_type'), 'exclude': lambda f: f is None }})
    max_entry_count: Optional[float] = dataclasses.field(default=100, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('max_entry_count'), 'exclude': lambda f: f is None }})
    r"""Number of entries to log. This destination is for testing only. So it won't make sense to log infinitely. The maximum is 1,000 entries."""
    



class LoggingType(str, Enum):
    FIRST_N = 'FirstN'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class FirstNEntries:
    r"""Log first N entries per stream."""
    additional_properties: Optional[Dict[str, Any]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'exclude': lambda f: f is None }})
    logging_type: Optional[LoggingType] = dataclasses.field(default=LoggingType.FIRST_N, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('logging_type'), 'exclude': lambda f: f is None }})
    max_entry_count: Optional[float] = dataclasses.field(default=100, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('max_entry_count'), 'exclude': lambda f: f is None }})
    r"""Number of entries to log. This destination is for testing only. So it won't make sense to log infinitely. The maximum is 1,000 entries."""
    



class TestDestinationType(str, Enum):
    LOGGING = 'LOGGING'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class Logging:
    logging_config: LoggingConfiguration = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('logging_config') }})
    r"""Configurate how the messages are logged."""
    additional_properties: Optional[Dict[str, Any]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'exclude': lambda f: f is None }})
    test_destination_type: Optional[TestDestinationType] = dataclasses.field(default=TestDestinationType.LOGGING, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('test_destination_type'), 'exclude': lambda f: f is None }})
    



@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class DestinationDevNull:
    test_destination: TestDestination = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('test_destination') }})
    r"""The type of destination to be used"""
    DESTINATION_TYPE: Final[DevNull] = dataclasses.field(default=DevNull.DEV_NULL, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('destinationType') }})
    


LoggingConfiguration = Union[FirstNEntries, EveryNThEntry, RandomSampling]

TestDestination = Union[Logging, Silent, Throttled, Failing]
